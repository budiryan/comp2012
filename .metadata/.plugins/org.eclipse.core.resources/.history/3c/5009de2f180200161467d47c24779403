///*
// * TODO.cpp
// *
// *  Created on: Apr 10, 2016
// *      Author: Budi Ryan
// */
//#include "TODO.h"
//
///*
// *
// * IMPLEMENTATION OF WEAPONRIFLE
// *
// *
// */
//WeaponRifle::WeaponRifle() {
//	weapon_name = "Rifle";
//	min_range = 1;
//	max_range = 8;
//	power = 10;
//}
//
//WeaponRifle::~WeaponRifle() {
//}
//
//int WeaponRifle::attack() {
//	return power;
//}
//
//bool WeaponRifle::isInRange(int att_x, int att_y, int ene_x, int ene_y) const {
//	int distance = abs(att_x - ene_x) + abs(att_y - ene_y);
//	if (distance >= min_range && distance <= max_range
//			&& (att_x == ene_x || att_y == ene_y))
//		return true;
//
//	return false;
//}
//
///*
// *
// *
// * IMPLEMENTATION OF WEAPONSUPERRIFLE
// *
// *
// */
//WeaponSuperRifle::WeaponSuperRifle() {
//	weapon_name = "Super Rifle";
//	min_range = 1;
//	max_range = 10;
//	power = 15;
//}
//
//WeaponSuperRifle::~WeaponSuperRifle() {
//}
//
//int WeaponSuperRifle::attack() {
//	return power;
//}
//
//bool WeaponSuperRifle::isInRange(int att_x, int att_y, int ene_x,
//		int ene_y) const {
//	int distance = abs(att_x - ene_x) + abs(att_y - ene_y);
//	if (distance >= min_range && distance <= max_range
//			&& (att_x == ene_x || att_y == ene_y))
//		return true;
//
//	return false;
//}
//
///*
// *
// *
// * IMPLEMENTATION OF WEAPONMISSLE
// *
// *
// */
//WeaponMissle::WeaponMissle(int p) {
//	weapon_name = "Missle";
//	min_range = 3;
//	max_range = 8;
//	power = p;
//	usedForAttack = false;
//	healing = false;
//}
//
//WeaponMissle::~WeaponMissle() {
//
//}
//
//int WeaponMissle::attack() {
//	if (!usedForAttack) {
//		usedForAttack = true;
//		return power;
//	}
//	return power;
//}
//
//bool WeaponMissle::isInRange(int att_x, int att_y, int ene_x, int ene_y) const {
//	int distance = abs(att_x - ene_x) + abs(att_y - ene_y);
//	if (usedForAttack == true)
//		return false;
//	else {
//		if (distance >= min_range && distance <= max_range)
//			return true;
//		else
//			return false;
//	}
//	return false;
//}
//
///*
// *
// *
// * IMPLEMENTATION FOR WEAPONFIST
// *
// *
// */
//WeaponFist::WeaponFist(int p) {
//	weapon_name = "Fist";
//	min_range = 1;
//	max_range = 1;
//	power = p;
//}
//
//WeaponFist::~WeaponFist() {
//}
//
//int WeaponFist::attack() {
//	return power;
//}
//
///*
// *
// *
// * REDEFINITION OF ROBOT::ATTACK() FUNCTION
// *
// *
// */
//
//int Robot::attack(Robot* robot, Weapon* weapon) {
//	int damage;
//	int enemyX;
//	int enemyY;
//	robot->getXY(enemyX, enemyY);
//
//	if (robot->getAlly() == getAlly()
//			|| !(weapon->isInRange(x, y, enemyX, enemyY)))
//		return 0;
//
//	//If the robot uses fist...
//	if (weapon->getName() == "Fist" && getAlly() != robot->getAlly()
//			&& robot->getAtt() >= getAtt()) {
//		damage = max((robot->getAtt() * weapon->attack() - getDef()), 1);
//		setHP(hp - damage);
//		return (-1 * damage);
//	}
//
//	damage = max(getAtt() * weapon->attack() - robot->getDef(), 1);
//	robot->setHP(robot->getHP() - damage);
//	return damage;
//}
//
///*
// *
// *
// * IMPLEMENTATION OF ROBOTHEALER
// *
// *
// */
//
//RobotHealer::RobotHealer(string s, int health, int speeds, int attk, int deff) :
//		Robot(s, health, speeds, attk, deff) {
//}
//
//RobotHealer::~RobotHealer() {
//}
//
//int RobotHealer::attack(Robot * robot, Weapon * weapon) {
//	int enemyX;
//	int enemyY;
//	robot->getXY(enemyX, enemyY);
//	if ((robot->getAlly() == getAlly())
//			&& (abs(enemyX - x) + abs(enemyY - y) == 1)) {
//		//heal the shit, extra conditioning first
//		if ((robot->getHP() + 100) >= robot->getMaxHP()) {
//			robot->setHP(robot->getMaxHP());
//			return (-100);
//		} else {
//			robot->setHP(robot->getHP() + 100);
//			return (-100);
//		}
//	}
//	//If the weapon is out of range...
//	if (!(weapon->isInRange(x, y, enemyX, enemyY))
//			|| getAlly() == robot->getAlly())
//		return 0;
//
//	int damage;
//
////Make a case for special weapons
////Case for Weapon Fist
//	if (weapon->getName() == "Fist" && getAlly() != robot->getAlly()
//			&& robot->getAtt() >= getAtt()) {
//		damage = max((robot->getAtt() * weapon->attack() - getDef()), 1);
//		setHP(hp - damage);
//		return (-1 * damage);
//	}
//
//	//Otherwise just make it other weapons
//	damage = max(getAtt() * weapon->attack() - robot->getDef(), 1);
//	robot->setHP(robot->getHP() - damage);
//	return damage;
//
//}
//
///*
// *
// *
// * IMPLEMENTATION OF ROBOTHOPPER
// *
// *
// */
//RobotHopper::RobotHopper(string n, int health, int attk, int deff) :
//		Robot(n, health, 3, attk, deff) {
//}
//
//RobotHopper::~RobotHopper() {
//}
//
//bool RobotHopper::isInRange(int aX, int aY) const {
//	if (aX < 0 || aX > ARENA_W || aY < 0 || aY > ARENA_H)
//		return false;
//
//	if ((abs(aX - x) + abs(aY - y) == speed) && abs(aX - x) < 3
//			&& abs(aY - y) < 3) {
//		return true;
//	}
//
//	return false;
//
//}
//
///*
// *
// *
// * Implementation of RobotHoppingHealer
// *
// *
// */
//
//RobotHoppingHealer::RobotHoppingHealer(string n, int health, int attk, int deff) :
//		Robot(n, health, 3, attk, deff), RobotHealer(n, health, 3, attk, deff), RobotHopper(
//				n, health, attk, deff) {
//}
//
//RobotHoppingHealer::~RobotHoppingHealer() {
//}
//

/*
 * TODO.cpp
 *
 *  Created on: Apr 11, 2016
 *      Author: jeffrywicaksana
 */

#include "TODO.h"

//Overriding Function

int Robot::attack(Robot* robot, Weapon* weapon) {
	if (robot == nullptr|| weapon == nullptr)
	return 0;

	if (robot->my_ally == this->my_ally || !(weapon->isInRange(x, y, robot->x, robot->y)))
	return 0;
	if((weapon->getName () == "Fist") && (att <= robot->att)) {
		//For Fist Algorithm
		int damage = max(robot->att * weapon->attack() - this->def, 1);
		this->setHP(this->hp - damage);
		return damage;
	}
	int damage = max(this->att * weapon->attack() - robot->def, 1);
	robot->setHP(robot->hp - damage);
	return damage;
}

//Implementation of WeaponRifle
WeaponRifle::WeaponRifle() {
	weapon_name = "Rifle";
	min_range = 1;
	max_range = 8;
	power = 10;
}

WeaponRifle::~WeaponRifle() {
}

int WeaponRifle::attack() {
	return power;
}

bool WeaponRifle::isInRange(int att_x, int att_y, int ene_x, int ene_y) const {
	int distanceX = abs(att_x - ene_x);
	int distanceY = abs(att_y - ene_y);
	if (((distanceX >= min_range) && (distanceX <= max_range)
			&& (att_y == ene_y))
			|| ((distanceY <= max_range) && (distanceY >= min_range)
					&& (att_x == ene_x)))
		return true;
	return false;
}

//Implementation of Weapon Super Rifle
WeaponSuperRifle::WeaponSuperRifle() {
	weapon_name = "SuperRifle";
	min_range = 1;
	max_range = 10;
	power = 15;
}

WeaponSuperRifle::~WeaponSuperRifle() {
}

int WeaponSuperRifle::attack() {
	return power;
}

bool WeaponSuperRifle::isInRange(int att_x, int att_y, int ene_x,
		int ene_y) const {
	int distanceX = abs(att_x - ene_x);
	int distanceY = abs(att_y - ene_y);
	if (((distanceX >= min_range) && (distanceX <= max_range)
			&& (att_y == ene_y))
			|| ((distanceY <= max_range) && (distanceY >= min_range)
					&& (att_x == ene_x)))
		return true;
	return false;
}

//Implementation of WeaponMissile
WeaponMissle::WeaponMissle(int aPower) {
	weapon_name = "Missle";
	min_range = 3;
	max_range = 8;
	power = aPower;
	shoot_count = true;
}

WeaponMissle::~WeaponMissle() {
}

int WeaponMissle::attack() {
	shoot_count = false;
	return power;
}

bool WeaponMissle::isInRange(int att_x, int att_y, int ene_x, int ene_y) const {
	if (!shoot_count)
		return false;
	int distance = abs(att_x - ene_x) + abs(att_y - ene_y);
	if (distance >= min_range && distance <= max_range)
		return true;
	return false;
}

//Implementation of WeaponFist
WeaponFist::WeaponFist(int aPower) {
	weapon_name = "Fist";
	min_range = 1;
	max_range = 1;
	power = aPower;
}

WeaponFist::~WeaponFist() {
}

int WeaponFist::attack() {
	return power;
}

bool WeaponFist::isInRange(int att_x, int att_y, int ene_x, int ene_y) const {
	int distance = abs(att_x - ene_x) + abs(att_y - ene_y);
	if (distance == min_range)
		return true;
	return false;
}

//Implementation of Robot Healer
RobotHealer::RobotHealer(string aName, int aMax_hp, int aSpeed, int aAtt,
		int aDef) :
		Robot(aName, aMax_hp, aSpeed, aAtt, aDef) {
}

RobotHealer::~RobotHealer() {
} //No need to do anything, weapon will be deleted by base destructor

int RobotHealer::attack(Robot* robot, Weapon* weapon) {
	if (robot == nullptr|| weapon == nullptr)
	return 0;
	int robot_x, robot_y;
	robot->getXY(robot_x,robot_y);
	if (!(weapon->isInRange(x, y, robot_x, robot_y)))
	return 0;

	//Healing Friend
	if(robot->getAlly() == this->my_ally) {
		if((abs(x-robot_x) + abs(y-robot_y)) == 1) {
			int newHP = min(robot->getHP() + 100, robot->getMaxHP());
			robot->setHP(newHP);
			return -100;
		}
		return 0;
	}
	// Attacking the enemy
	if((weapon->getName () == "Fist") && (att <= robot->getAtt()) ) {
		//For Fist Algorithm
		int damage = max(robot->getAtt() * weapon->attack() - this->def, 1);
		this->setHP(this->hp - damage);
		return damage;
	}
	int damage = max(this->att * weapon->attack() - robot->getDef(), 1);
	robot->setHP(robot->getHP() - damage);
	return damage;
}
//Implementation of RobotHopper
RobotHopper::RobotHopper(string aName, int aMax_hp, int aAtt, int aDef) :
		Robot(aName, aMax_hp, 3, aAtt, aDef) {
}

RobotHopper::~RobotHopper() {
} //No need to do anything, weapon will be deleted by base destructor
bool RobotHopper::isInRange(int aX, int aY) const {
	if (aX < 0 || aX > ARENA_W || aY < 0 || aY > ARENA_H)
		return false;

	if ((abs(aX - x) + abs(aY - y) == speed) && (x != aX) && (y != aY)) {
		return true;
	}

	return false;
}
//Implementation of Robot Hopping Healer
RobotHoppingHealer::RobotHoppingHealer(string aName, int aMax_hp, int aAtt,
		int aDef) :
		Robot(aName, aMax_hp, 3, aAtt, aDef), RobotHealer(aName, aMax_hp, 3,
				aAtt, aDef), RobotHopper(aName, aMax_hp, aAtt, aDef) {
}

RobotHoppingHealer::~RobotHoppingHealer() {
} //No need to do anything, weapon will be deleted by base destructor




